LAB HTML-02 — Respostas Guiadas (PT-PT)
Semântica, Formulários e Recursos Externos (HTML5)

============================================================
0) Conceitos base
============================================================

Q: O que significa “HTML semântico”?
A: HTML semântico é usar elementos (tags) cujo nome descreve o papel do conteúdo no documento (ex.: <header>, <nav>, <main>, <footer>, <section>, <article>, <form>, <label>). Em vez de usar apenas <div>/<span> (genéricos), escolhem-se elementos que comunicam significado para humanos, motores de pesquisa e tecnologias de apoio.

Q: Porque é que uma estrutura semântica melhora acessibilidade e manutenibilidade?
A: 
- Acessibilidade: leitores de ecrã e navegação por teclado usam “landmarks” (marcos) e a hierarquia semântica para permitir saltos rápidos (ex.: “ir para a navegação”, “ir para o conteúdo principal”), além de melhorar a compreensão de contexto.
- Manutenibilidade: o código fica auto-explicativo (menos comentários para explicar “o que é este bloco”), facilita refactor e trabalho em equipa, e reduz risco de alterações acidentais.

Q: Qual é a diferença entre estrutura (HTML), apresentação (CSS) e comportamento (JavaScript)?
A:
- HTML: estrutura e significado (o que cada parte “é”).
- CSS: apresentação/estilo (como “parece”).
- JavaScript: comportamento/interacção (o que “faz” em resposta ao utilizador).

============================================================
FASE 1 — Estrutura Semântica e Formulário
============================================================

------------------------------------------------------------
Passo 1) Estrutura base
------------------------------------------------------------

Q: Para que serve <!DOCTYPE html>?
A: Indica HTML5 e força o browser a renderizar em “Standards Mode” (modo de padrões). Sem DOCTYPE válido, alguns browsers podem entrar em “Quirks Mode”, que imita comportamentos antigos e pode causar inconsistências no CSS/layout (ex.: cálculos de largura, margens, box model).

Q: Para que serve <html lang="pt-PT">?
A: Define a língua principal do documento. Impactos:
- Acessibilidade: leitores de ecrã escolhem pronúncia/voz adequada e regras linguísticas (ex.: leitura de abreviaturas, hifenização, dicionários).
- SEO/Indexação: motores de busca entendem a língua e servem a página para utilizadores/queries relevantes; melhora a interpretação do conteúdo.

Q: Para que serve <meta charset="UTF-8">?
A: Define a codificação de caracteres (UTF-8). Evita caracteres “corrompidos” (mojibake) em acentos e símbolos (ç, ã, €, etc.). Deve estar cedo no <head> para o browser interpretar correctamente desde o início.

Q: Para que serve <title> ... </title>?
A: Define o título da página (separador do browser, favoritos) e é usado como título nos resultados de pesquisa. Melhora usabilidade e SEO.

------------------------------------------------------------
Passo 2) Header
------------------------------------------------------------

Q: Porque é que o título do evento e o logótipo devem estar dentro de <header>?
A: O <header> representa o conteúdo introdutório/cabeçalho do documento (ou de uma secção). Título e identidade visual (logótipo) são tipicamente elementos introdutórios; colocá-los em <header> torna a estrutura mais clara e navegável.

Q: Qual é o significado semântico de <header>?
A: É um contentor semântico para conteúdo introdutório: título, subtítulo, resumo, logótipo, metainformação inicial. Nota: pode existir mais do que um <header> (por exemplo, dentro de <article>), porque o significado é contextual.

Q: Como é que leitores de ecrã interpretam <header>?
A: É entendido como região estrutural (conteúdo de cabeçalho). Ajuda o utilizador a perceber o início/introdução do documento/da secção. Em conjunto com <nav>, <main> e <footer>, melhora a navegação por marcos.

Alternativas e consequências:
- Alternativa: <div class="header"> (não semântico).
- Consequência negativa: perde-se significado; navegação por landmarks fica mais pobre; maior dependência de classes/ARIA para comunicar o papel.

------------------------------------------------------------
Passo 3) Navegação
------------------------------------------------------------

Q: Porque usar <nav> em vez de <div>?
A: <nav> identifica explicitamente uma secção de navegação (links principais). Tecnologias de apoio conseguem listar/“saltar para” a navegação. Um <div> não comunica intenção.

Q: Que tipo de conteúdo pertence dentro de <nav>?
A: Ligações de navegação principais (ex.: âncoras para secções “Sobre”, “Programa”, “Inscrição”, “Contactos”, ou links para páginas). Pode conter listas (<ul><li><a>...), botões de menu, etc., desde que o propósito seja navegar.

Q: Como é que a estrutura de navegação melhora usabilidade?
A: 
- Facilita orientação do utilizador (onde estou e para onde posso ir).
- Permite acesso rápido a secções (especialmente em páginas longas).
- Para acessibilidade, permite a leitores de ecrã e teclados saltar directamente para a navegação, evitando tabulação excessiva.

Alternativas e consequências:
- Alternativa: links soltos fora de <nav>.
- Consequência negativa: pior organização; leitores de ecrã não reconhecem “isto é navegação”; menos previsibilidade.

------------------------------------------------------------
Passo 4) Conteúdo principal
------------------------------------------------------------

Q: Porque o formulário deve estar dentro de <main>?
A: <main> deve conter o conteúdo principal e único da página — aqui, o objectivo principal é a inscrição no evento, logo o formulário é núcleo do conteúdo. Isto cria um landmark essencial para acessibilidade (“saltar para o conteúdo principal”).

Q: Porque deve existir apenas um <main> por página?
A: Porque o documento deve ter um único conteúdo principal. Múltiplos <main> criam ambiguidade para leitores de ecrã e para a estrutura do documento (não fica claro qual é “o” conteúdo principal). A regra melhora consistência e acessibilidade.

Q: O que são “document landmarks” e porque importam?
A: São marcos semânticos/estruturais (ex.: <header>, <nav>, <main>, <footer>, e também ARIA landmarks) que permitem navegação rápida e compreensão da estrutura por tecnologias de apoio.

------------------------------------------------------------
Passo 5) Criação do formulário (campos e validação)
------------------------------------------------------------

Notas gerais (boas práticas):
- Usar <label for="..."> associado ao id do campo.
- Preferir validação nativa do browser (type, required, minlength, maxlength, pattern) como primeira linha, mas nunca confiar só nela.
- Definir autocomplete (ex.: name, email, tel), inputmode quando útil (ex.: numeric para códigos).
- Acessibilidade: mensagens de erro claras e, se necessário, aria-describedby para ajudar a explicar requisitos.

(1) Nome completo
Q: Porque type="text" é apropriado?
A: O nome é texto livre. type="text" permite entrada geral, compatível com leitores de ecrã e teclados.

Q: Que validação nativa oferece?
A: Não valida formato por defeito, mas permite:
- required (obrigatório),
- minlength/maxlength (tamanho),
- pattern (se quiseres restringir).

Q: Restrições recomendadas?
A:
- required
- minlength (ex.: 2 ou 3) para evitar entradas vazias/curtas
- maxlength (ex.: 80 ou 120) para evitar abuso e problemas no backend
- pattern (opcional e com cuidado): evitar ser demasiado rígido (nomes têm hífen, apóstrofo, acentos). Se usado, deve aceitar letras Unicode e espaços/hífens.
- autocomplete="name"

Impacto em usabilidade/integridade:
- Limites impedem lixo/inputs absurdos.
- Pattern demasiado rígido pode excluir nomes reais (impacto negativo na usabilidade).

(2) Email
Q: Porque type="email"?
A: O browser aplica validação de formato de email e em mobile apresenta teclado optimizado com “@”.

Q: Que validação nativa oferece?
A: Verifica se parece um email (contém “@” e domínio num formato aceitável). Pode usar multiple se aceitasse vários, mas aqui tipicamente não.

Q: Restrições recomendadas?
A:
- required
- maxlength (ex.: 254, limite comum em emails)
- autocomplete="email"

Impacto:
- Melhor usabilidade (teclado e validação).
- Ainda assim pode passar emails inválidos do ponto de vista real (ex.: domínio inexistente). Backend deve confirmar.

(3) Telefone
Q: Porque type="tel"?
A: Não impõe formato rígido (porque telefones variam), mas em mobile mostra teclado telefónico.

Q: Que validação nativa oferece?
A: Por defeito, praticamente nenhuma (a não ser required). Para formato, usa-se pattern.

Q: Restrições recomendadas?
A:
- required (se for obrigatório)
- pattern (ex.: aceitar “+351” opcional e 9 dígitos para PT, se o evento for nacional)
- minlength/maxlength (ex.: 9 a 15, dependendo do padrão)
- autocomplete="tel"
- inputmode="tel" (ou numeric, consoante abordagem)

Impacto:
- Usabilidade melhora em mobile.
- Pattern demasiado nacional pode frustrar utilizadores estrangeiros; escolher consoante público-alvo.

(4) Página pessoal
Q: Porque type="url"?
A: O browser valida se o formato parece um URL e em mobile pode sugerir teclado adequado.

Q: Que validação nativa oferece?
A: Verifica formato de URL (ex.: requer esquema em muitos browsers, como https://). Ainda assim não garante que o site exista.

Q: Restrições recomendadas?
A:
- required (se obrigatório) ou opcional
- pattern (normalmente não necessário)
- placeholder com exemplo (ex.: https://exemplo.pt)
- autocomplete="url"
- maxlength (para evitar abuso)

Impacto:
- Ajuda a recolher dados consistentes.
- Pode haver fricção se o utilizador introduzir “www...” sem esquema; UX deve orientar (placeholder/ajuda).

(5) Código postal (Portugal)
Q: Porque usar pattern?
A: Código postal PT tem formato típico NNNN-NNN. pattern permite impor este formato no cliente.

Q: Validação nativa?
A: Sem pattern, seria texto livre. Com pattern, o browser valida contra regex.

Q: Restrições recomendadas?
A:
- required
- inputmode="numeric" (ou text com pattern; numeric não permite hífen nativamente em alguns teclados)
- pattern="\d{4}-\d{3}" (exemplo)
- maxlength=8
- placeholder="1234-567"
- aria-describedby com explicação curta do formato

Impacto:
- Melhora integridade do dado.
- Se o evento for internacional, este formato pode não servir; nesse caso, o campo deve ser adaptado (ou permitir formatos diferentes).

(6) Tipo de bilhete (select)
Q: Porque <select>?
A: Quando existe um conjunto finito de opções, <select> garante consistência e evita erros de escrita.

Q: Validação nativa?
A: Com required, o browser obriga a escolher uma opção diferente do placeholder (se configurado).

Q: Restrições recomendadas?
A:
- required
- primeira opção desactivada e com value vazio (ex.: “Escolhe um tipo…”)
- opções claras (ex.: Normal, Estudante, VIP)

Impacto:
- Excelente integridade de dados.
- Alternativa: radio buttons (melhor quando poucas opções e queres visibilidade imediata). Consequência de escolher mal: se forem poucas opções, radio pode ser mais rápido e acessível do que select.

(7) Termos e condições (checkbox)
Q: Porque checkbox?
A: É uma aceitação binária (aceito/não aceito). Checkbox representa exactamente isso.

Q: Validação nativa?
A: required em checkbox exige que esteja marcado para submeter.

Q: Restrições recomendadas?
A:
- required
- texto com link para termos
- label grande e claro (clicável)
- se necessário, aria-describedby para clarificar

Impacto:
- Garante consentimento no cliente.
- Backend deve registar consentimento e versionamento dos termos (segurança/legal).

(8) Upload de foto (file)
Q: Porque <input type="file">?
A: É o mecanismo nativo para anexar ficheiros.

Q: Validação nativa?
A: Permite seleccionar ficheiro; validações adicionais:
- accept limita tipos (ex.: image/* ou .jpg,.png)
- required se obrigatório

Q: Restrições recomendadas?
A:
- accept="image/*" (ou tipos específicos)
- (opcional) limitar tamanho e dimensões no frontend via JS, mas o essencial é no backend
- explicar requisitos (tamanho máximo, formatos) via texto associado

Impacto:
- Usabilidade melhora com accept.
- Segurança: o tipo MIME e extensão podem ser falsificados; backend deve validar, sanitizar e controlar armazenamento.

(9) Botão de submissão (submit)
Q: Porque type="submit"?
A: Submete o formulário e activa validação nativa do browser antes do envio (a não ser que exista novalidate).

Q: Restrições recomendadas?
A:
- Texto claro (ex.: “Submeter inscrição”)
- Considerar disabled/spinner via JS (com cuidado) para evitar duplo envio

Impacto:
- UX previsível.
- Backend deve ser idempotente ou proteger contra reenvios.

------------------------------------------------------------
Passo 6) Validação obrigatória e segurança
------------------------------------------------------------

Q: Como funciona o atributo required?
A: required impede a submissão do formulário se o campo estiver vazio (ou, no caso de checkbox, não marcado; no caso de select, se mantiver value vazio). O browser mostra uma mensagem de erro e foca o campo.

Q: O que acontece se a validação do cliente for contornada?
A: É possível contornar (desactivar JS, enviar pedidos via ferramentas, alterar HTML). Resultado: o servidor pode receber dados inválidos/maliciosos. Portanto, toda validação importante deve existir também no backend.

Q: Porque é que isto é relevante para segurança?
A: Sem validação no servidor, há risco de:
- dados corruptos/inconsistentes na base de dados,
- ataques de injecção (dependendo do sistema),
- upload de ficheiros perigosos,
- abuso (spam, inputs gigantes, etc.).

------------------------------------------------------------
Passo 7) Footer
------------------------------------------------------------

Q: Que tipo de conteúdo pertence em <footer>?
A: Informação de rodapé: direitos de autor, contactos, morada, links secundários, política de privacidade, termos, redes sociais, nota legal.

Q: Porque é semanticamente separado do <main>?
A: <main> contém o conteúdo principal; <footer> contém informação de suporte/encerramento. Separar melhora estrutura, navegação e manutenção.

Alternativas e consequências:
- Alternativa: colocar tudo no <main> ou <div>.
- Consequência: mistura-se conteúdo principal com metainformação, piorando acessibilidade e clareza.

------------------------------------------------------------
Passo 8) Validação HTML (W3C Validator, etc.)
------------------------------------------------------------

Q: Porque é importante validar HTML?
A: Para garantir conformidade com standards, evitar bugs de renderização, melhorar acessibilidade e compatibilidade entre browsers. HTML inválido pode quebrar estrutura, labels, foco, e leitores de ecrã.

Q: Que erros um validador detecta?
A: 
- Tags mal aninhadas, não fechadas, atributos inválidos/duplicados
- IDs repetidos
- Estruturas semânticas incorrectas
- Problemas com forms (ex.: labels sem for/id, types inválidos)
- Uso de elementos/atributos obsoletos
- Alguns problemas que afectam acessibilidade (embora para acessibilidade haja ferramentas específicas adicionais)

============================================================
FASE 2 — Recursos Externos e Performance
============================================================

------------------------------------------------------------
Passo 1) JavaScript externo no <head>
------------------------------------------------------------

Q: Porque colocar <script> no <head>?
A: Pode ser necessário quando o script define configurações iniciais, polyfills, ou precisa estar disponível cedo. Porém, por defeito, um <script> no <head> sem estratégia bloqueia o parser do HTML.

Q: O que acontece se não houver estratégia de carregamento?
A: Por defeito, <script src="..."> bloqueia a construção do DOM: o browser pára de analisar o HTML, descarrega e executa o JS, e só depois continua. Isto pode atrasar renderização (piorar LCP/TTI).

Q: O que é async?
A: O script é descarregado em paralelo e executado assim que terminar o download, sem esperar pela análise completa do HTML. Pode executar antes de o DOM estar pronto e a ordem entre scripts async não é garantida.

Q: O que é defer?
A: O script é descarregado em paralelo, mas a execução é adiada até o HTML estar totalmente analisado (DOMContentLoaded). A ordem entre scripts defer é preservada.

Q: Quando usar async?
A: Para scripts independentes, que não dependem do DOM nem de outros scripts e não são críticos para a lógica da página (ex.: analytics, trackers, widgets isolados). Risco: se depender do DOM, pode falhar por executar cedo.

Q: Quando usar defer?
A: Para scripts que dependem do DOM e/ou quando existe dependência entre scripts e ordem importa (ex.: script principal da página, scripts que manipulam o formulário após o DOM existir). Geralmente é a escolha mais segura para JS de aplicação.

Alternativas e consequências:
- Alternativa: colocar <script> no fim do <body> (evita bloquear o parsing quase sempre).
- Consequência de escolher mal:
  - async em script que precisa do DOM: erros/intermitência.
  - sem defer/sem mover para o fim: atraso na renderização.

------------------------------------------------------------
Passo 2) Imagens
------------------------------------------------------------

Q: Como carregar uma imagem externa?
A: Usar <img src="URL-ou-caminho" alt="...">. O src pode ser caminho relativo (assets locais) ou absoluto (CDN/domínio). Sempre incluir alt apropriado.

Q: O que é lazy loading (loading="lazy")?
A: É um mecanismo para adiar o carregamento de imagens fora do ecrã (below the fold) até estarem perto de entrar na viewport. Reduz consumo inicial de rede e acelera a renderização inicial.

Q: Quando usar loading="lazy"?
A: Em imagens não críticas para a primeira renderização (ex.: galeria abaixo do primeiro ecrã). Evitar em imagens “hero” acima do fold, pois pode atrasar a imagem principal e piorar métricas de performance e experiência.

Impacto em performance/UX:
- Positivo: menos bytes iniciais e carregamento mais rápido do conteúdo visível.
- Negativo se mal usado: imagem importante aparece tarde, “saltos” visuais, pior LCP.

Boas práticas adicionais:
- Definir width/height (ou aspect-ratio via CSS) para reduzir CLS (layout shift).
- Usar formatos modernos (WebP/AVIF) e tamanhos adequados.

------------------------------------------------------------
Passo 3) Vídeo
------------------------------------------------------------

Q: Que atributos melhoram usabilidade? (controls, autoplay, muted)
A:
- controls: mostra controlos (play/pause/volume) — essencial para usabilidade.
- autoplay: tenta iniciar automaticamente, mas muitas vezes é bloqueado.
- muted: frequentemente necessário para permitir autoplay (políticas de browsers).
- loop: repete automaticamente (opcional).
- preload: controla pré-carregamento (auto/metadata/none).

Q: Quais são considerações de performance ao embutir vídeo?
A:
- Vídeo é pesado: pode consumir muita largura de banda e bloquear recursos.
- Autoplay pode prejudicar dados móveis e bateria; também pode ser intrusivo.
- Usar poster (imagem inicial) para boa UX antes do play.
- Considerar carregar vídeo apenas quando necessário (lazy, ou só quando o utilizador interage).
- Preferir streaming/host adequado (CDN) e formatos compatíveis.
- Se for um embed (ex.: iframe), pode carregar scripts adicionais (impacto no desempenho e privacidade).

Alternativas e consequências:
- Alternativa: imagem + link para vídeo (carregar só quando clicado).
- Consequência de embutir sempre: maior tempo de carregamento, pior experiência em redes lentas.

============================================================
Checklist final (resumo do que importa)
============================================================

- Semântica: <header>, <nav>, <main>, <footer> com propósito correcto.
- Acessibilidade: labels associados, alt correcto, landmarks claros, textos de ajuda para padrões.
- Validação: usar validação nativa, mas validar sempre no backend (segurança).
- Recursos externos: scripts com defer/async conforme dependências; evitar bloqueios.
- Performance: lazy para imagens fora do ecrã; cuidado com vídeo (peso e autoplay).
